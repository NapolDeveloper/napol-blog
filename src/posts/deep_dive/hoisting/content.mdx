---
title: '호이스팅? TDZ? 그게 뭔데'
desc: var, let, const 그리고 프론트엔드 면접 단골 질문 호이스팅과 TDZ. 면접관보다 자세히 알아보자.
date: 2025-01-20
thumbnail: /posts/deep_dive/hoisting/thumbnail.png
---

## 들어가며

최근 자바스크립트를 공부한 사람이라면 변수를 선언할 때 `let` 과 `const` 키워드 익숙할 것이다. 하지만 2015년 `Javascript ES6(이하 ES6)` 가 발표되기 전까지 많은 자바스크립트 프로그램은 `var` 키워드를 사용하여 변수를 선언했다.

그리고 시간이 지나 `ES6` 가 등장하면서 우리가 사용하는 `let` 과 `const` 가 새롭게 추가되었다. 자바스크립트는 이미 변수 선언 키워드가 있음에도 불구하고 왜 새로운 키워드를 추가했을까?

이번 포스팅에서는 이 궁금증을 해결해 보려고 한다.

---

## var 키워드

`var` 키워드는 `ES6` 가 등장하기 전까지 자바스크립트에서 변수를 선언하기 위해 사용된 키워드다. `var` 키워드는 몇가지 특이한 특징을 가지고 있으며, 이러한 특징들 때문에 개발자들이 의도치 않은 코드 동작을 자주 경험했다.

![아니 이게 왜 동작하는데..](/posts/deep_dive/hoisting/why.png)

### 키워드 생략

변수를 선언할 때 `var` 키워드는 생략할 수 있다. 아래 코드를 보면 `var` 키워드를 사용한 `a` 변수와 사용하지 않은 `b` 변수가 모두 정상적으로 동작하는 것을 확인할 수 있다.

```javascript
var a = 10;
b = 20;

console.log(a); // 10
console.log(b); // 20
```

### 중복 선언

`var` 키워드를 사용해 선언한 변수는 재선언이 가능하다. 일반적으로 동일한 변수명으로 변수를 다시 선언하는 경우는 드물겠지만, 전역에서 사용하는 변수라면 상황이 달라질 수 있다. 만약 우리가 전역에서 선언해둔 변수명을 잊어버리고 동일한 변수명으로 새로운 변수를 선언한다면, 의도치 않은 동작으로 이어질 수 있다.

> 전역 변수 사용은 지양하자
> 특히 윈도우 객체에 동일한 이름의 프로퍼티가 들어간다고 생각해보자. ~~(생각만 해도 어지럽다)~~

```javascript
var value = 10;
console.log(value); // 10

var value = 20;
console.log(value); // 20
```

### 함수 레벨 스코프

혹시 스코프라는 용어를 들어본적이 있는가? 스코프를 우리말로 번역하면 `범위` 라는 뜻을 가진다.
`var` 키워드는 함수 레벨 스코프를 사용한다. 아래 코드에는 `main()` 함수 내부에서 선언된 변수 `value` 가 있으며, 전역에 선언된 `value` 도 존재한다. 함수 바깥에서 `value` 에 접근하니 `10` 이 출력되는 모습을 확인할 수 있다.
즉, `var` 키워드로 선언된 변수는 함수 레벨 스코프에서만 사용 가능하다.

```javascript
var value = 1;

function main() {
  var value = 2;
}

console.log(value); // 1
```

함수 레벨 스코프를 사용하기 때문에 아래와 같이 블록 내부에서 변수를 선언했다면, 나중에 할당된 `20`의 값이 출력된다.

```javascript
var value = 10;

if (true) {
  var value = 20;
}

console.log(value); // 20
```

> if문과 for문은 함수가 아닌 블록이다.

### var의 호이스팅

이 포스팅을 작성하게 된 이유가 호이스팅 이녀석 때문이다. 아래 코드를 보자.

```javascript
var a = 10;
console.log(a);

console.log(b);
var b = 20;
```

먼저 `a` 변수를 선언과 동시에 `10` 으로 초기화한 후 출력했다. 그 다음 `b` 변수를 출력한 후에 `b` 변수를 선언했다.

우리가 일반적으로 알고 있는 인터프리터 언어라면 위 코드는 어떻게 동작할까? `b` 변수를 선언하기 전에 참조하려고 했으니 에러가 발생할 것이라고 생각할 수 있다. 하지만 우리의 자바스크립트는 `console.log(b)` 의 값으로 `undefined` 출력된다.~~(아니 인터프리터 언어라면서)~~ 이렇게 동작하는 이유는 다음과 같다.

> 자바스크립트의 모든 선언문은 런타임 이전에 코드 평가 과정에서 실행된다.

즉, 자바스크립트는 코드 평가 단계에서 선언문을 스코프 내 최상단으로 끌어올린다. 이후 선언문을 제외한 코드를 한 줄씩 순차적으로 실행하게 된다.

```javascript
// 변수 선언이 끌어올려짐
var a;
var b;

// 변수 선언 이후 초기화와 실행
a = 10;

console.log(a); // 10

console.log(b); // undefined (초기화는 아직 이루어지지 않음)
b = 20;
```

여기서 알 수 있는 내용은 `var` 키워드로 선언된 변수는 선언과 동시에 `undefined` 로 초기화 되기 때문에 참조 에러가 발생하지 않는다.

## let, const 키워드

2015년 `ES6` 가 등장하면서 우리가 자주 사용하게 된 `let` 과 `const` 키워드가 새롭게 추가되었다. 이 두 키워드는 `var` 키워드에서 발생했던 문제들을 해결할 수 있는 기능들을 갖추고 있다.

참고로 2015년 인터뷰에서 자바스크립트 창시자는 `var` 키워드가 잘못되었다고 인정한 바 있다.

> "If I could go back in time, I would have designed JavaScript differently. var was a quick decision for dynamic scoping, but over time, we've seen the issues it can cause. That's why we now have let and const."
> (번역: "시간을 되돌릴 수 있다면 JavaScript를 다르게 설계했을 것입니다. var는 동적 스코핑을 위해 빠르게 결정된 것이었지만, 시간이 지나면서 그로 인해 발생하는 문제들을 알게 되었습니다. 그래서 이제는 let과 const를 사용하게 된 것입니다.")

### 재선언 불가능

`let` 과 `const` 로 선언된 변수는 동일한 변수명으로 재선언이 불가능하다.

```javascript
let value = 10;
let value = 20;

// SyntaxError: Identifier 'value' has already been declared
```

### 블록 레벨 스코프

`let` 과 `const` 키워드는 블록 레벨 스코프를 사용한다. 따라서 블록 내부에서 선언된 변수는 블록 외부에서 접근할 수 없다.

```javascript
let value = 10;

if (true) {
  let value = 20;
  console.log(value); // 20
}

console.log(value); // 10
```

`let` 과 `const` 키워드는 블록 레벨 스코프를 사용한다고 했다. 즉 코드 평가 단계에서 변수 선언이 블록 레벨 내 최상단으로 일어난다. 예시 코드를 작성해보면 아래와 같다.

```javascript
let value;
value = 10;

if (true) {
  let value;

  value = 20;
  console.log(value); // 20
}

console.log(value); // 10
```

### 선언과 할당

`let` 키워드는 선언과 초기화를 동시에 하지 않아도 된다. 즉 아래와 같은 코드는 유효한 코드이다.

```javascript
let value;
value = 20;
```

하지만 `const` 키워드는 반드시 선언과 동시에 초기화를 함께 해야한다.

```javascript
const value1; // SyntaxError: Missing initializer in const declaration

const value2 = 20;
```

### 상수 선언

`const` 키워드를 사용하면 상수를 선언할 수 있다. 상수란 무엇인가?
위대한 위키백과에 아래와 같이 설명되어 있다.

> 수학에서 상수란 그 값이 변하지 않는 불변량으로, 변수의 반대말이다.

즉 변하지 않는 값인 상수는 `const` 키워드를 이용해 선언할 수 있다. 그렇기에 상수로 선언된 값을 재할당하려고 하면 에러가 발생한다.

```javascript
const a = 10;
a = 20; // Uncaught TypeError: Assignment to constant variable.
```

하지만 `Array`, `Object` 와 같이 `Call by Reference` 호출 방식을 사용하는 타입은 내부 프로퍼티 변경이 가능하다.
주의할 점은 참조를 변경하려고 한다면 IDE가 ~~(거품을 물고)~~ 안된다고 에러 문구를 보여줄 것이다.

```javascript
// 참조 변경
const obj1 = { value: 10 };
obj1 = { value: 20 }; // Uncaught TypeError: Assignment to constant variable.

// 객체 프로퍼티 변경
const obj2 = { value: 10 };
obj2.value = 30;
console.log(obj); // { value: 30 }
```

### let, const의 호이스팅

지금까지 `let` 과 `const` 가 어떤 동작을 하는지 알아봤으니 호이스팅이 일어났을때 `var` 와 어떻게 다른지 확인할 수 있다.

```javascript
console.log(value); // ReferenceError: Cannot access 'value' before initialization
let value = 10;
```

위 코드는 `value` 를 선언 및 할당하기 전에 참조하는 코드를 작성한 것이다. `var` 키워드로 선언한 변수는 `undefined` 를 출력했지만, `let` 키워드로 선언된 변수에 접근하려고 하면 초기화 전에는 접근할 수 없다는 참조 에러가 발생한다.

이렇게 참조 에러가 발생하는 구역, 즉 참조가 불가능한 영역을 `TDZ(Temporal Dead Zone)` 라고 한다.

---

여기까지 잘 읽었다면 누군가에게 `호이스팅` 이 무엇인지, `TDZ` 가 무엇인지에 대해 간략하게 설명할 수 있는 수준이 되었을 것이다.

하지만 우리는 한 단계 더 나아가 보려고 한다. 자바스크립트를 해석하고 실행하는 `v8` 엔진에서는 `var`, `let`, `const` 키워드를 이용할 때 어떤 방식으로 처리하는지 알아보자.

## v8

필자는 `c++` 을 사용할 줄 몰라서 gpt와 함께 `v8` 엔진 코드를 분석해 보았다.

변수 선언은 `Parser::DeclareVariable` 함수에서 처리된다.

```c++
// /src/parsing/parser.cc

Variable* Parser::DeclareVariable(const AstRawString* name, VariableKind kind,
                                  VariableMode mode, InitializationFlag init,
                                  Scope* scope, bool* was_added, int begin,
                                  int end) {
  Declaration* declaration;
  if (mode == VariableMode::kVar && !scope->is_declaration_scope()) {
    DCHECK(scope->is_block_scope() || scope->is_with_scope());
    declaration = factory()->NewNestedVariableDeclaration(scope, begin);
  } else {
    declaration = factory()->NewVariableDeclaration(begin);
  }
  Declare(declaration, name, kind, mode, init, scope, was_added, begin, end);
  return declaration->var();
}
```
