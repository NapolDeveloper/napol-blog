---
title: '호이스팅? TDZ? 그게 뭔데'
desc: 프론트엔드 면접 단골 질문 호이스팅과 TDZ. 면접관보다 자세히 알아보자.
date: 2025-01-20
thumbnail: /posts/deep_dive/hoisting/thumbnail.png
---

## 들어가며

최근 자바스크립트를 공부한 사람이라면 변수를 선언할 때 `let`과 `const` 키워드가 익숙할 것이다. 하지만 2015년 `Javascript ES6(이하 ES6)`가 세상에 발표되기 전까지 많은 자바스크립트 프로그램은 `var` 키워드를 사용해서 변수를 선언했다.

그리고 시간이 지나 `ES6`가 등장하면서 새로운 키워드인 `let`과 `const`가 등장했다.
자바스크립트는 이미 변수 선언 키워드가 있음에도 불구하고 굳이 새로운 키워드를 추가한 것일까?

이번 포스팅에서는 이 궁금증을 해결해 보려고 한다.

---

## var 키워드

`var` 키워드는 `ES6`가 등장하기 전까지 자바스크립트에서 변수를 선언하기 위해 사용된 키워드이다. `var` 키워드는 몇가지 특이한 특징을 가지고 있는데, 이 특징들 때문에 개발자들이 의도치 않은 코드 동작 ~~(`var`가 덕지덕지 붙어있는 코드는 읽기가 힘들다..)~~ 을 많이 경험하게 된다.

![아니 이게 왜 동작하는데..](/posts/deep_dive/hoisting/why.png)

### 키워드 생략

변수를 선언할 때 `var` 키워드는 생략이 가능하다. 아래 코드를 보면 키워드를 사용한 `a` 변수와 사용하지 않은 `b` 변수 모두 정상적으로 동작함을 볼 수 있다.

```javascript
var a = 10;
b = 20;

console.log(a); // 10
console.log(b); // 20
```

### 중복 선언

`var` 키워드를 사용해서 선언한 변수는 재선언이 가능하다. 보통의 경우 아래와 같이 동일한 변수명으로 변수를 선언하는 일은 잘 없을 것이다. 하지만 전역에서 사용하는 변수라면 어떨까? 전역에서 선언해둔 변수명을 개발자가 잊어버리고 동일한 변수명으로 새로운 변수를 선언한다면 의도치 않은 동작으로 이어질 수 있다.

> 전역 변수 사용은 지양하자

```javascript
var value = 10;
console.log(value); // 10

var value = 20;
console.log(value); // 20
```

### 함수 레벨 스코프

혹시 스코프라는 용어를 들어본적이 있는가? 스코프를 우리말로 번역하면 '범위'라는 뜻을 가지고 있다.
`var` 키워드는 함수 레벨 스코프를 사용한다. 즉 `var` 키워드로 선언된 변수는 함수 레벨 스코프에서만 사용가능하다.

```javascript
var value = 1;

function main() {
  var value = 2;
}

console.log(value); // 1
```

함수 레벨 스코프를 사용하기 때문에 아래와 같은 코드에서는 나중에 할당된 20의 값이 출력된다.

```javascript
var value = 10;

if (true) {
  var value = 20;
}

console.log(value); // 20
```

> if문은 함수가 아닌 블록이다.

### var의 호이스팅

이 포스팅을 작성하게 된 이유가 호이스팅 이녀석 때문이다. 아래 코드를 보자.

```javascript
var a = 10;
console.log(a);

console.log(b);
var b = 20;
```

먼저 `a`변수를 선언과 동시에 `10`으로 초기화했다. 그리고 출력했다.
다음으로는 `b`변수를 출력한 후 `b`변수를 선언했다.

우리가 평소에 알고있는 인터프리터 언어라면 위 코드는 어떻게 동작할까?

`b`변수를 선언하기 전에 참조하려고 했으니 에러가 발생할 것이라고 생각할 것이다. 하지만 우리의 자바스크립트는 `console.log(b)`의 값으로 `undefined`를 출력한다.~~(아니 인터프리터 언어라면서)~~ 이렇게 동작하는 이유는 다음과 같다.

> 자바스크립트의 모든 선언문은 런타임 이전에 코드 평가 과정에서 실행된다.

즉 자바스크립트는 코드 평가 단계에서 아래와 같이 선언문을 스코프 내 최상단으로 끌어올린다. 그리고 코드 평가 과정 이후 선언문을 제외한 코드를 한 줄씩 순차적으로 실행한다.

```javascript
// 변수 선언이 끌어올려짐
var a;
var b;

// 변수 선언 이후 초기화와 실행
a = 10;

console.log(a); // 10

console.log(b); // undefined (초기화는 아직 이루어지지 않음)
b = 20;
```

여기서 알 수 있는 내용은 `var`키워드로 선언된 변수는 선언과 동시에 `undefined`로 초기화 되기 때문에 참조 에러가 발생하지 않는다.

## let, const 키워드

2015년 `ES6`가 등장하면서 우리가 자주 사용하고 있는 `let`과 `const`키워드가 등장했다. 이 두 키워드는 `var`키워드에서 야기되었던 문제들을 해결할 수 있는 기능들을 탑재했다.

참고로 2015년 인터뷰에서 자바스크립트 창시자는 `var`키워드가 잘못되었다고 인정했다.

> "If I could go back in time, I would have designed JavaScript differently. var was a quick decision for dynamic scoping, but over time, we've seen the issues it can cause. That's why we now have let and const."
> (번역: "시간을 되돌릴 수 있다면 JavaScript를 다르게 설계했을 것입니다. var는 동적 스코핑을 위해 빠르게 결정된 것이었지만, 시간이 지나면서 그로 인해 발생하는 문제들을 알게 되었습니다. 그래서 이제는 let과 const를 사용하게 된 것입니다.")

### 재선언 불가능

`let`과 `const`로 선언된 변수는 동일한 변수명으로 재선언이 불가능하다.

```javascript
let value = 10;
let value = 20;

// SyntaxError: Identifier 'value' has already been declared
```

### 블록 레벨 스코프

`let`과 `const`키워드는 블록 레벨 스코프를 사용한다. 위에서 봤던 `var`키워드와는 동작이 다르다는 것을 알 수 있다.

```javascript
let value = 10;

if (true) {
  let value = 20;
  console.log(value); // 20
}

console.log(value); // 10
```

`let`과 `const`키워드는 블록 레벨 스코프를 사용한다고 했다. 즉 코드 평가 단계에서 변수 선언이 블록 레벨 내 최상단으로 일어난다. 예시 코드를 작성해보면 아래와 같다.

```javascript
let value;
value = 10;

if (true) {
  let value;

  value = 20;
  console.log(value); // 20
}

console.log(value); // 10
```

### 선언과 할당

`let`키워드는 선언과 초기화를 동시에 하지 않아도 된다. 즉 아래와 같은 코드는 유효한 코드이다.

```javascript
let value;
value = 20;
```

하지만 `const`키워드는 선언과 동시에 초기화를 함께 해야한다.

```javascript
const value1; // SyntaxError: Missing initializer in const declaration

const value2 = 20;
```

## 상수 선언
